package merk

import (
	"github.com/stretchr/testify/require"
	"golang.org/x/crypto/blake2b"
	"testing"
)

func TestMarshal(t *testing.T) {
	var leftLink, rightLink Link

	hash := blake2b.Sum256([]byte(""))
	rTree := newTree([]byte("rKey"), []byte("rValue"))

	leftLink = &Pruned{
		ch: [2]uint8{1, 2},
		k:  []byte("key"),
		h:  hash,
	}

	rightLink = &Stored{
		ch: [2]uint8{2, 0},
		t:  rTree,
		h:  hash,
	}

	tree := newTree([]byte("key"), []byte("value"))
	tree.left = leftLink
	tree.right = rightLink

	var buf []byte
	buf = tree.marshal(buf)

	require.EqualValues(t, []byte{0x0, 0x0, 0x0, 0x3, 0x6b, 0x65, 0x79, 0x1, 0xe, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x1, 0xe, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x76, 0x61, 0x6c, 0x75, 0x65}, buf)
}

func TestUnMarshalTree(t *testing.T) {
	var data []byte = []byte{0x0, 0x0, 0x0, 0x3, 0x6b, 0x65, 0x79, 0x1, 0xe, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x1, 0xe, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x76, 0x61, 0x6c, 0x75, 0x65}

	hash := blake2b.Sum256([]byte(""))

	tree := unmarshalTree(data)

	require.EqualValues(t, tree.key(), []byte("key"))
	require.EqualValues(t, tree.value(), []byte("value"))
	require.EqualValues(t, tree.link(true).hash(), hash)
	require.EqualValues(t, tree.link(false).hash(), hash)
}

func TestTreeCommit(t *testing.T) {
	tree := buildTree()

	committer := newCommitter(nil, tree.height(), 1)

	tree.commit(committer)

	require.EqualValues(t, tree.link(true).linkType(), StoredLink)
	require.EqualValues(t, tree.link(true).hash(), Hash{0x4f, 0x85, 0x14, 0x8c, 0x5, 0x23, 0x93, 0xce, 0x97, 0xf1, 0x9, 0xdd, 0xc5, 0x49, 0x7b, 0x74, 0xf7, 0x41, 0x51, 0x2d, 0x5f, 0x3d, 0x6e, 0x95, 0x37, 0x4a, 0xf7, 0x75, 0x27, 0xff, 0x5d, 0x90})
	require.EqualValues(t, tree.link(true).tree().link(true).linkType(), PrunedLink)
	require.EqualValues(t, tree.link(true).tree().link(false).linkType(), PrunedLink)
	require.EqualValues(t, tree.link(true).tree().link(true).key(), []byte("key0"))
	require.EqualValues(t, tree.link(true).tree().link(false).key(), []byte("key2"))
}

func TestVerify(t *testing.T) {
	tree := buildTree()

	require.NoError(t, tree.verify())
}

func buildTree() *Tree {
	llTree := newTree([]byte("key0"), []byte("value0"))
	lrTree := newTree([]byte("key2"), []byte("value2"))

	llLink := &Modified{
		ch: [2]uint8{0, 0},
		t:  llTree,
	}

	lrLink := &Modified{
		ch: [2]uint8{0, 0},
		t:  lrTree,
	}

	lTree := newTree([]byte("key1"), []byte("value1"))
	lTree.left = llLink
	lTree.right = lrLink
	rTree := newTree([]byte("key4"), []byte("value4"))

	lLink := &Modified{
		ch: [2]uint8{1, 1},
		t:  lTree,
	}

	rLink := &Stored{
		ch: [2]uint8{0, 0},
		t:  rTree,
		h:  NullHash,
	}

	tree := newTree([]byte("key3"), []byte("value3"))
	tree.left = lLink
	tree.right = rLink

	return tree
}
