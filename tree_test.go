package merk

import (
	"github.com/stretchr/testify/require"
	"testing"
	"golang.org/x/crypto/blake2b"
)

func TestMarshal(t *testing.T) {
	var leftLink, rightLink *Link

	hash := blake2b.Sum256([]byte(""))
	rTree := newTree([]byte("rKey"), []byte("rValue"))

	leftLink = &Link{
		linkType: Pruned,
		hash: hash,
		key: []byte("key"),
		childHeights: [2]uint8{1,2},
	}

	rightLink = &Link{
		linkType: Stored,
		hash: hash,
		childHeights: [2]uint8{2,0},
		tree: rTree,
	}

	tree := newTree([]byte("key"), []byte("value"))
	tree.left = leftLink
	tree.right = rightLink

	buf, _ := tree.marshal()

	require.EqualValues(t, []byte{0x05, 0x00, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x29, 0xfa, 0x60, 0x3b, 0x25, 0x5c, 0x1a, 0x18, 0xcb, 0xaa, 0x2e, 0x02, 0xb8, 0x27, 0x56, 0xbd, 0x59, 0x52, 0x7c, 0xa3, 0x92, 0xb4, 0x82, 0xfa, 0x4e, 0x25, 0xf8, 0x39, 0x4a, 0x1f, 0x04, 0xad, 0x01, 0x03, 0x00, 0x00, 0x00, 0x6b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x01, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00, 0x72, 0x4b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x02, 0x00}, buf)
}

func TestUnMarshalTree(t *testing.T) {
	var data []byte = []byte{0x05, 0x00, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x29, 0xfa, 0x60, 0x3b, 0x25, 0x5c, 0x1a, 0x18, 0xcb, 0xaa, 0x2e, 0x02, 0xb8, 0x27, 0x56, 0xbd, 0x59, 0x52, 0x7c, 0xa3, 0x92, 0xb4, 0x82, 0xfa, 0x4e, 0x25, 0xf8, 0x39, 0x4a, 0x1f, 0x04, 0xad, 0x01, 0x03, 0x00, 0x00, 0x00, 0x6b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x01, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00, 0x72, 0x4b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x02, 0x00}

	hash := blake2b.Sum256([]byte(""))

	tree, _ := unmarshalTree([]byte("key"), data)

	require.EqualValues(t, tree.key(), []byte("key"))
	require.EqualValues(t, tree.value(), []byte("value"))
	require.EqualValues(t, tree.link(true).key, []byte("key"))
	require.EqualValues(t, tree.link(true).hash, hash)
	require.EqualValues(t, tree.link(true).childHeights, [2]uint8{1,2})
	require.EqualValues(t, tree.link(false).key, []byte("rKey"))
	require.EqualValues(t, tree.link(false).hash, hash)
	require.EqualValues(t, tree.link(false).childHeights, [2]uint8{2,0})
}

func TestTreeCommit(t *testing.T) {
	llTree := newTree([]byte("llKey"), []byte("llValue"))
	lrTree := newTree([]byte("lrKey"), []byte("lrValue"))

	llLink := &Link{
		linkType: Modified,
		pendingWrites: uint8(1),
		childHeights: [2]uint8{0,0},
		tree: llTree,
	}

	lrLink := &Link{
		linkType: Modified,
		pendingWrites: uint8(1),
		childHeights: [2]uint8{0,0},
		tree: lrTree,
	}

	lTree := newTree([]byte("lKey"), []byte("lValue"))
	lTree.left = llLink
	lTree.right = lrLink
	rTree := newTree([]byte("rKey"), []byte("rValue"))

	lLink := &Link{
		linkType: Modified,
		pendingWrites: uint8(2),
		childHeights: [2]uint8{1,1},
		tree: lTree,
	}

	rLink := &Link{
		linkType: Stored,
		hash: NullHash,
		childHeights: [2]uint8{0,0},
		tree: rTree,
	}

	tree := newTree([]byte("key"), []byte("value"))
	tree.left = lLink
	tree.right = rLink

	committer := newCommitter(nil, tree.height(), 1)
	tree.commit(committer)

	require.EqualValues(t, tree.link(true).linkType, Stored)
	require.EqualValues(t, tree.link(true).hash, lTree.hash())
	require.EqualValues(t, tree.link(true).tree.link(true).linkType, Pruned)
	require.EqualValues(t, tree.link(true).tree.link(false).linkType, Pruned)
	require.EqualValues(t, tree.link(true).tree.link(true).key, llTree.key())
	require.EqualValues(t, tree.link(true).tree.link(false).key, lrTree.key())
}
