package merk

import (
	"github.com/stretchr/testify/require"
	"golang.org/x/crypto/blake2b"
	"testing"
)

func TestMarshal(t *testing.T) {
	var leftLink, rightLink *Link

	hash := blake2b.Sum256([]byte(""))
	rTree := newTree([]byte("rKey"), []byte("rValue"))

	leftLink = &Link{
		linkType:     Pruned,
		hash:         hash,
		key:          []byte("key"),
		childHeights: [2]uint8{1, 2},
	}

	rightLink = &Link{
		linkType:     Stored,
		hash:         hash,
		childHeights: [2]uint8{2, 0},
		tree:         rTree,
	}

	tree := newTree([]byte("key"), []byte("value"))
	tree.left = leftLink
	tree.right = rightLink

	buf, _ := tree.marshal()

	require.EqualValues(t, []byte{0x05, 0x00, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x29, 0xfa, 0x60, 0x3b, 0x25, 0x5c, 0x1a, 0x18, 0xcb, 0xaa, 0x2e, 0x02, 0xb8, 0x27, 0x56, 0xbd, 0x59, 0x52, 0x7c, 0xa3, 0x92, 0xb4, 0x82, 0xfa, 0x4e, 0x25, 0xf8, 0x39, 0x4a, 0x1f, 0x04, 0xad, 0x01, 0x03, 0x00, 0x00, 0x00, 0x6b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x01, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00, 0x72, 0x4b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x02, 0x00}, buf)
}

func TestUnMarshalTree(t *testing.T) {
	var data []byte = []byte{0x05, 0x00, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x29, 0xfa, 0x60, 0x3b, 0x25, 0x5c, 0x1a, 0x18, 0xcb, 0xaa, 0x2e, 0x02, 0xb8, 0x27, 0x56, 0xbd, 0x59, 0x52, 0x7c, 0xa3, 0x92, 0xb4, 0x82, 0xfa, 0x4e, 0x25, 0xf8, 0x39, 0x4a, 0x1f, 0x04, 0xad, 0x01, 0x03, 0x00, 0x00, 0x00, 0x6b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x01, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00, 0x72, 0x4b, 0x65, 0x79, 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2, 0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1, 0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87, 0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8, 0x02, 0x00}

	hash := blake2b.Sum256([]byte(""))

	tree, _ := unmarshalTree([]byte("key"), data)

	require.EqualValues(t, tree.key(), []byte("key"))
	require.EqualValues(t, tree.value(), []byte("value"))
	require.EqualValues(t, tree.link(true).key, []byte("key"))
	require.EqualValues(t, tree.link(true).hash, hash)
	require.EqualValues(t, tree.link(true).childHeights, [2]uint8{1, 2})
	require.EqualValues(t, tree.link(false).key, []byte("rKey"))
	require.EqualValues(t, tree.link(false).hash, hash)
	require.EqualValues(t, tree.link(false).childHeights, [2]uint8{2, 0})
}

func TestTreeCommit(t *testing.T) {
	tree := buildTree()

	committer := newCommitter(nil, tree.height(), 1)
	tree.commit(committer)

	require.EqualValues(t, tree.link(true).linkType, Stored)
	require.EqualValues(t, tree.link(true).hash, Hash{0x4f, 0x85, 0x14, 0x8c, 0x5, 0x23, 0x93, 0xce, 0x97, 0xf1, 0x9, 0xdd, 0xc5, 0x49, 0x7b, 0x74, 0xf7, 0x41, 0x51, 0x2d, 0x5f, 0x3d, 0x6e, 0x95, 0x37, 0x4a, 0xf7, 0x75, 0x27, 0xff, 0x5d, 0x90})
	require.EqualValues(t, tree.link(true).tree.link(true).linkType, Pruned)
	require.EqualValues(t, tree.link(true).tree.link(false).linkType, Pruned)
	require.EqualValues(t, tree.link(true).tree.link(true).key, []byte("key0"))
	require.EqualValues(t, tree.link(true).tree.link(false).key, []byte("key2"))
}

func TestVerify(t *testing.T) {
	tree := buildTree()

	require.NoError(t, tree.verify())
}

func buildTree() *Tree {
	llTree := newTree([]byte("key0"), []byte("value0"))
	lrTree := newTree([]byte("key2"), []byte("value2"))

	llLink := &Link{
		linkType:      Modified,
		pendingWrites: uint8(1),
		childHeights:  [2]uint8{0, 0},
		tree:          llTree,
	}

	lrLink := &Link{
		linkType:      Modified,
		pendingWrites: uint8(1),
		childHeights:  [2]uint8{0, 0},
		tree:          lrTree,
	}

	lTree := newTree([]byte("key1"), []byte("value1"))
	lTree.left = llLink
	lTree.right = lrLink
	rTree := newTree([]byte("key4"), []byte("value4"))

	lLink := &Link{
		linkType:      Modified,
		pendingWrites: uint8(2),
		childHeights:  [2]uint8{1, 1},
		tree:          lTree,
	}

	rLink := &Link{
		linkType:     Stored,
		hash:         NullHash,
		childHeights: [2]uint8{0, 0},
		tree:         rTree,
	}

	tree := newTree([]byte("key3"), []byte("value3"))
	tree.left = lLink
	tree.right = rLink

	return tree
}
